# AutoJailbreak Technical Guide (HOW-TO)

This document provides a technical overview of the AutoJailbreak application, its architecture, and guidelines for development.

## ğŸš€ Full Stack Architecture

AutoJailbreak is a full-stack application composed of a Python backend for core logic and a modern web frontend for the user interface.

-   **Backend (Python + Flask):** A powerful core responsible for device communication (via ADB, libimobiledevice), exploit execution, and automation logic. It exposes a REST API for the frontend.
-   **Frontend (React):** A modern, cross-platform application (targetable for Electron) that provides a clean and intuitive user interface for managing devices and triggering actions.

## ğŸ”Œ API Contract (Client-Server Communication)

The frontend communicates with the backend via a simple REST API running on `http://127.0.0.1:5000`.

### `GET /detect`

-   **Description:** Scans for physically connected iOS and Android devices.
-   **Method:** `GET`
-   **Response Body (Success):** `200 OK`
    ```json
    [
      {
        "id": "device-udid-or-serial",
        "name": "iPhone 13 Pro",
        "os": "iOS",
        "osVersion": "15.1",
        "status": "Unlocked",
        "serial": "...",
        "imei": "...",
        "storage": "..."
      }
    ]
    ```
-   **Response Body (Error):** `500 Internal Server Error`
    ```json
    { "error": "Failed to execute detection command." }
    ```

### `POST /execute`

-   **Description:** Executes a specific action (like a jailbreak or recovery) and streams the log output back to the client in real-time.
-   **Method:** `POST`
-   **Request Body:**
    ```json
    { "actionName": "Name of the action to execute" }
    ```
-   **Response Body (Success):** `200 OK`
    This is a streaming response with `Content-Type: text/plain`. The server holds the connection open and sends data line-by-line as it's generated by the executed script. The frontend reads this stream. Each line is prefixed to indicate its type:
    -   `LOG: Some log message from the tool...`
    -   `STATUS: Patching kernel...`
    -   `PROGRESS: 50`
    -   `ERROR: Something went wrong...`

## ğŸ“‚ Project Structure (Monorepo)

```
AutoJailbreak/
â”œâ”€â”€ components/             # React UI components
â”œâ”€â”€ hooks/                  # Custom React hooks
â”œâ”€â”€ services/               # Frontend services (API, logger, etc.)
â”œâ”€â”€ server/                 # Python/Flask Backend
â”‚   â”œâ”€â”€ bin/                # For storing command-line tools & scripts
â”‚   â”œâ”€â”€ core/               # Core backend logic (detector, executor)
â”‚   â”œâ”€â”€ app.py              # Main Flask application
â”‚   â””â”€â”€ requirements.txt    # Python dependencies
â”œâ”€â”€ App.tsx                 # Main React component
â”œâ”€â”€ index.html              # Entry point for the desktop app
â”œâ”€â”€ mobile.html             # Entry point for the mobile web dashboard
â”œâ”€â”€ HOW_TO.md               # This file
â””â”€â”€ README.md
```

## ğŸ› ï¸ Backend Setup & Running

To run the full-stack application, you must run the Python backend server.

### Prerequisites

You must have the following command-line tools installed and available in your system's PATH:
-   **Python 3.x** and `pip`.
-   **`libimobiledevice`:** For detecting iOS devices (`ideviceinfo`).
    -   On macOS: `brew install libimobiledevice`
    -   On Linux: `sudo apt-get install libimobiledevice-utils`
-   **`adb` (Android Debug Bridge):** For detecting Android devices. This is typically installed with Android Studio.

### Running the Server

1.  **Open a terminal** or command prompt.
2.  **Navigate to the `server` directory** in the project root:
    ```bash
    cd server
    ```
3.  **Install the Python dependencies** using `pip`:
    ```bash
    pip install -r requirements.txt
    ```
4.  **Run the Flask server:**
    ```bash
    python app.py
    ```
5.  The server will start and listen on `http://127.0.0.1:5000`. **Leave this terminal running.**

## ğŸ’¡ Integrating Real Exploits and Tools

The backend is designed to be a high-level orchestrator that executes external command-line tools.

-   **Mechanism:** It uses Python's `subprocess` module to run any shell command.
-   **Location:** Real exploit binaries and scripts (like `checkra1n`, custom Python/shell scripts) should be placed in the `server/bin/` directory.
-   **Execution:** The `server/core/executor.py` module contains a mapping between the `actionName` received from the frontend and the actual command to be executed. To add a new real tool, you simply add an entry to this map.
-   **Output:** To be compatible with the frontend's `ProcessMonitor`, any tool or script you run should output its status in the prefixed format (`LOG:`, `PROGRESS:`, etc.). You can write simple wrapper scripts to format the output of existing tools if needed.
